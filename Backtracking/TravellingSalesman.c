/* 
	PS. Please refer to STring Permutation Program Before this.
	Program to find solution for Travelling Salesman problem by brute forcing ( Finding the minimum cost from all possible Permutations,
	Permutations are generated by backtracking 
	Written for S3 CP lab.
	INput : a Undirected graph with N nodes and edges between all nodes.
*/
#include<stdio.h>
int dist[20][20]; // Distance Matrix, it stores distance between each cities
int n;	// NUmber of Cities
int path[20],min,cost; // array to store min cost path and min cost
void swap(int *x,int *y);
void permutation(int a[],int l,int r);
int main(){
	int i,j,city[20];
	min=99999999;// Setting minimum cost to +ve INF (arbitary max value)
	printf(" Enter number of cities : ");
	scanf("%d",&n);
	for(i=0;i<n;i++)	// filling cities initial permutation
		city[i]=i;  
	for(i=0;i<n;i++){
		for(j=i+1;j<n;j++){   
			if(i!=j){
				printf(" Enter distance between city %d to city %d : ",i+1,j+1);
				scanf("%d",&dist[i][j]);
   				dist[j][i]=dist[i][j]; // Undirected Graph, so making Symmetric MAtrix
			}
		}
	}
	permutation(city,0,n-1);// Here we go to permutation function where minimum cost s calculated
	printf(" Minimum cost : %d\n Optimal Path is : ",min);
	for(i=0;i<n-1;i++)
		printf("%d -> ",path[i]+1);
	printf("%d -> %d\n",path[n-1]+1,path[0]+1);
}

void swap(int *x,int *y){  // Swap function, for permutation function
	int temp;
	temp=*x;
	*x=*y;
	*y=temp;
}
void permutation(int a[],int l,int r){  // permutation by recursion
	int i,j;
	if(l==r){		// it is next permutation
		cost=0;
//	for(i=0;i<n;i++)			printf("%d ",a[i]);
//	printf("\n");
		for(i=0;i<n-1;i++)	// find cost of this path
			cost+=dist[a[i]][a[i+1]];
		cost+=dist[a[n-1]][a[0]];	// return to started city
		if(cost<min){	// minimum path, store it
			min=cost;
			for(j=0;j<n;j++)		// stor the path
				path[j]=a[j];
		}
	}
	else{
		for(i=l;i<=r;i++){		// Iterate through each city
			swap((a+l),(a+i)); // Swap two cities 
			permutation(a,l+1,r); // Go this way and get our permutation
			swap((a+l),(a+i)); // Swap them back.. ( Backtracking
		}
	}
}


